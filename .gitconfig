[alias]
	test = "!f() { [[ ! $2 ]] && { echo hi; return 1; }; echo $2; }; f"
	df = diff
	dfs = diff --staged
	ui = always
	status = always
	branch = always
	diff = always
	interactive = always
	a = add
	aa = add --all
	ae = add --edit
	ai = add --interactive
	amend = commit --amend -C HEAD
	ap = add --patch
	au = add --update
	authors = !git log --pretty=format:%aN | sort | uniq -c | sort -r
	ls = "!f()   { git show-ref | cut -f 2 -d' ' | cut -f 3-5 -d'/' | sort | egrep '^[ ]*'$1; }; f"
	tls = "!f()  { git show-ref | grep 'refs/tags' | cut -f 2 -d' ' | cut -f 3-5 -d'/' | sed 's/v//' | sed 's/\\./,/g' | sort -n | sed 's/,/\\./g' | egrep '^[ ]*'$1; }; f"
	bls = "!f()  { git show-ref | grep 'refs/heads' | cut -f 2 -d' ' | cut -f 3-5 -d'/' | sort | egrep '^[ ]*'$1;  }; f"
	rbls = "!f() { git show-ref | grep 'refs/remotes/origin' | cut -f 2 -d' ' | cut -f 4-5 -d'/' | sort | egrep '^[ ]*'$1; }; f"
	b = branch -vv
	bs = branch-status
	br = "!f() { git branch --track $1 origin/$1; git checkout $1; }; f"
	brcr = "!f() { [[ ! $3 ]] && { echo An existing branch is required ; return 1; }; git branch $2 $3 && git push -u origin $2 && git checkout $2; }; f-"
	brmv = "!f() { git branch -m $1 $2 && git push origin :$1 && git push -u origin $2; }; f"
	fr = "!f() { git brmv $1 Frozen-$1; }; f"
	ufr = "!f() { echo git brmv $1 ${1/Frozen-/}; }; f"
	brrm = "!f() { git branch -d $1; git push origin :$1 && git remote prune origin; }; f"
	brex = "!f() { git rev-parse --verify $1 >& /dev/null; }; f"
	bro = "!f() { cb=$(git symbolic-ref -q HEAD | cut -d/-f 3); git checkout $1 && git reset --hard origin/$1; git checkout $cb; }; f"
	brh = "!f() { cb=$(git symbolic-ref -q HEAD | cut -d/-f 3); git checkout $1 && git reset --hard $cb && git push --force; git checkout $cb; }; f"
	c = commit
	ca = commit --all -m
	cam = commit --amend
	changes = diff --name-status -r
	check = diff --check
	cl = clean -d -f
	cla = clean -d -x -i
	clvs = clean -d -x -i -e '*.dbmdl' -e '*.user' -e '*.suo'
	cm = commit --message
	co = checkout
	cob = checkout -b
	conflicted = grep --name-only --full-name '<<<<<<< HEAD'
	cpc = cherry-pick
	d = diff --ignore-all-space
	dc = diff --cached --ignore-all-space
	dcw = diff --color-words
	div = divergence
	dt = difftool
	h = help
	i = integrate
	is = wtf --relations --short
	iall = "!f() { git i Continuous && git i Test && git i Pre-Production; }; f"
	ic = "!f() { git checkout $1 && git reset --hard $2 && git push --force; }; f"
	icall = "!f() { git ic Test $1 && git ic Pre-Production $1; }; f"
	ir = "!f() { cb=$(git symbolic-ref -q HEAD | cut -d/-f 3); git checkout $1 && git reset --hard origin/$1; git checkout $cb; }; f"
	irall = "!f() { git ir Continuous && git ir Test && git ir Pre-Production; }; f"
	iup = "!f() { git irall && git up; }; f"
	latest = for-each-ref --count=10 --sort=-committerdate --format='%(committerdate:short) %(refname:short)'
	ls-ignored = ls-files --exclude-standard --ignored --others
	m = merge -s recursive -X patience
	markdown = !BN=$(git name-rev --name-only HEAD) && git log --no-merges --grep=$BN --pretty=oneline | awk -F$BN: '{print \"-\", $NF}' | uniq
	mm = merge --no-ff
	merge-branch = !git checkout master && git merge @{-1}
	msg = commit --allow-empty -m
	pick = cherry-pick
	pr = !hub pull-request
	prune-remotes = "!for remote in `git remote`; do git remote prune $remote; done"
	r = remote
	rb = rebase
	rba = rebase --abort
	rbc = rebase --continue
	rbs = rebase --skip
	rbi = rebase --interactive --autosquash
	rbia = "!f() { git rebase --interactive --autosquash HEAD~$((1 + $(git --no-pager log --pretty=format:'%s' --abbrev-commit -40 | egrep '^fixup!' | wc -l))); }; f"
	rh = reset --hard
	rh = reset --hard
	rho = "!f() { git rh origin/$(git symbolic-ref -q HEAD | cut -d/-f 3); }; f"
	fix = "!f() { git commit -am \"fixup! $(git log -1 --format='%s' $1)\n\n$2\"; }; f"
	sq = "!f() { git commit -am \"squash! $(git log -1 --format='%s' $1)\n\n$2\"; }; f"
	s = status --short --branch
	sm = submodule
	sma = submodule add
	smu = submodule update --init
	st = stash
	stl = stash list
	stp = stash pop
	undo = reset --soft HEAD@{1}
	wd = diff --word-diff=color
	wdc = diff --word-diff=color--cached
	ft = fetch --tags
	push = push --tags
	rs = remote show
	rso = remote show origin
	rpo = remote prune origin
	ru = remote update --prune
	rua = "!f() { git ft; git rpo; }; f"
	tagcr = "!f() { git tag $1; git push origin $1; }; f"
	tagp = git push origin
	tagrm = "!f() { git tag -d $1; git push origin -d $1 && git remote prune origin; }; f"
	tagr = "!f() { git tagrm $1; git tagcr $1; }; f"
	rl = "!f() { git  reflog | head -40; }; f"
	l = !git --no-pager log --graph --pretty=format:'%Cred%h%Creset%C(yellow)%d%Creset %s' --abbrev-commit --date=relative -30
	ld = !git --no-pager log --graph --pretty='%cD %Cred%h%Creset%C(yellow)%d%Creset %s' --abbrev-commit --date=relative -30
	logo = !git --no-pager log --oneline -1
	logb = !git --no-pager log --oneline -20
	logg = log --graph --pretty=format:'%Cred%h%Creset%C(yellow)%d%Creset %s' --abbrev-commit --date=relative
	logd = log --graph --pretty=format:'%Cred%h%Creset %an -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset' --abbrev-commit --date=relative
	news = log -p HEAD@{1}..HEAD@{0}
[color]
	ui = auto
[core]
	autocrlf = false
	excludesfile = ~/.gitignore
	editor = \"C:/Program Files/Sublime Text 3/sublime_text.exe\" -w --multiinstance
[push]
	default = current
[diff]
	tool = bc
	guitool = bc
[difftool]
	prompt = false
[merge]
	tool = bc
[mergetool]
	prompt = false
	keepBackup = false
[rebase]
	autosquash = true
[user]
	name = John Butare
	email = john.butare@intel.com
[hub]
	host = github.intel.com
	protocol = https
[git-up "fetch"]
	prune = true
[git-up "rebase"]
	auto = false
[difftool "beyondcompare4"]
	path = C:/Program Files/Beyond Compare 4/bcomp.exe
	cmd = \"C:/Program Files/Beyond Compare 4/bcomp.exe\" \"$LOCAL\" \"$REMOTE\"
[mergetool "BeyondCompare4"]
	path = C:/Program Files/Beyond Compare 4/bcomp.exe
	cmd = \"C:/Program Files/Beyond Compare 4/bcomp.exe\" \"$LOCAL\" \"$REMOTE\" \"$BASE\" \"$MERGED\"
